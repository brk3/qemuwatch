// TODO(SamYaple): Sort replies into command responses and events
// TODO(SamYaple): Create listening socket for this daemon
// TODO(SamYaple): Launch QEMU instance after receiving command on socket
// TODO(SamYaple): Scan directory structure and (re)attach to sockets
// TODO(SamYaple): Write logs
// TODO(SamYaple): Improve error handling when talking to unix socket
// TODO(SamYaple): Build structs for responses from QMP (this can be autogenerated based on the master branch of QEMU and json2rust)
// TODO(SamYaple): Error handling for QMP responses (QMP/QEMU issues, not operating system related)
// TODO(SamYaple): Write tests

use std::sync::mpsc;
use std::thread;
use std::time;

mod qemu;

fn main() {
    let (command_tx, command_rx) = mpsc::channel();
    let (reply_tx, reply_rx) = mpsc::channel();
    let (event_tx, event_rx) = mpsc::channel();

    let mon = thread::spawn(move || {
        qemu::monitor("/tmp/vm.sock", command_rx, reply_tx, event_tx)
    });

    // NOTE(SamYaple): temporary thread that exists to clear the event channel
    thread::spawn(move || {loop {event_rx.recv().unwrap();}});

    // NOTE(SamYaple): Thread responsible for periodic health checks
    thread::spawn(move || {
        loop {
            command_tx.send("query-status".to_string()).unwrap();
            let response = reply_rx.recv().unwrap();
            println!("{}", response);
            thread::sleep(time::Duration::from_millis(10000));
        }
    });

    let _ = mon.join();
}
