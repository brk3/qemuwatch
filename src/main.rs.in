// TODO(SamYaple): Sort replies into command responses and events
// TODO(SamYaple): Create listening socket for this daemon
// TODO(SamYaple): Launch QEMU instance after receiving command on socket
// TODO(SamYaple): Scan directory structure and (re)attach to sockets
// TODO(SamYaple): Write logs
// TODO(SamYaple): Improve error handling when talking to unix socket
// TODO(SamYaple): Build structs for responses from QMP (this can be autogenerated based on the master branch of QEMU and json2rust)
// TODO(SamYaple): Error handling for QMP responses (QMP/QEMU issues, not operating system related)
// TODO(SamYaple): Write tests

use std::io::prelude::*;

use std::fmt;
use std::io::BufReader;
use std::os::unix::net::UnixStream;
use std::sync::mpsc;
use std::thread;
use std::time;

// TODO(SamYaple): Write specialized deserializer to prevent the need of having more than one struct per QMP response
#[derive(Deserialize, Debug)]
struct QemuInfo {
    #[serde(rename="QMP")]
    qmp: Info,
}

#[derive(Deserialize, Debug)]
struct Info {
    version: Version,
    capabilities: Vec<String>,
}

#[derive(Deserialize, Debug)]
struct Version {
    qemu: Qemu,
    package: String,
}

#[derive(Deserialize, Debug)]
struct Qemu {
    major: u8,
    micro: u8,
    minor: u8,
}

impl fmt::Display for Qemu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}.{}", self.major, self.minor, self.micro)
    }
}

#[derive(Serialize)]
struct Execute {
    #[serde(rename="execute")]
    command: String,
}

fn main() {
    let socket_path = "/tmp/vm.sock";
    let (command_tx, command_rx) = mpsc::channel();
    let (reply_tx, reply_rx) = mpsc::channel();
    let (event_tx, event_rx) = mpsc::channel();

    // NOTE(SamYaple): Thread responsible for interacting with socket
    let monitor = thread::spawn(move || {
        monitor(socket_path, command_rx, reply_tx, event_tx)
    });

    // NOTE(SamYaple): temporary thread that exists to clear the event channel
    thread::spawn(move || {loop {event_rx.recv().unwrap();}});

    // NOTE(SamYaple): Thread responsible for periodic health checks
    thread::spawn(move || {
        loop {
            command_tx.send("query-status".to_string()).unwrap();
            let response = reply_rx.recv().unwrap();
            println!("{}", response);
            thread::sleep(time::Duration::from_millis(10000));
        }
    });

    // NOTE(SamYaple): Hang until monitor thread ends
    // TODO(SamYaple): Properly monitor thread and possible restart threads if they die
    let _ = monitor.join();
}

fn execute(writer: &mut UnixStream, command: String) {
    let command = serde_json::to_string(&Execute{ command: command }).unwrap();
    writer.write_all(command.as_bytes()).unwrap();
}

fn monitor(socket_path: &str, command_rx: mpsc::Receiver<String>, reply_tx: mpsc::Sender<String>, event_tx: mpsc::Sender<String>) {
    // TODO(SamYaple): Error checking
    // TODO(SamYaple): socket timeout
    let mut socket = UnixStream::connect(socket_path).unwrap();
    let read_socket = socket.try_clone().unwrap();
    let mut reader = BufReader::new(read_socket);

    // NOTE(SamYaple): Read initial string from socket containing version and capability info
    let mut version_raw = String::new();
    match reader.read_line(&mut version_raw) {
        Ok(_)  => { },
        Err(x) => { println!("unexpected error: {}", x); return; },
    }
    let info: QemuInfo = serde_json::from_str(&version_raw).unwrap();
    let version = info.qmp.version;
    println!("Version: {}, Package:{}", version.qemu, version.package);

    // NOTE(SamYaple): At this time, there are no capabilites to negotiate, this is "future-proofing" for QMP
    // NOTE(SamYaple): Exit capability negotiation
    execute(&mut socket, "qmp_capabilities".to_string());
    match reader.read_line(&mut String::new()) {
        Ok(x)  => if x == 0 { return; },
        Err(x) => {
            println!("Unknown Error: {}", x);
            return;
        },
    }

    // NOTE(SamYaple): Worker thread recieves commands from channel and writes them to the socket
    thread::spawn(move || {
        loop {
            // NOTE(SamYaple): This is a blocking operation
            let command = command_rx.recv().unwrap();
            execute(&mut socket, command);
        }
    });

    loop {
        let mut line = String::new();
        // NOTE(SamYaple): This is a blocking operation
        match reader.read_line(&mut line) {
            Ok(x)  => if x == 0 { return; },
            Err(x) => {
                println!("Unknown Error: {}", x);
                return;
            },
        }
        // TODO(SamYaple): Seperate these into events and replies
        reply_tx.send(line.trim().to_string()).unwrap();
        event_tx.send(line.trim().to_string()).unwrap();
    }
}
